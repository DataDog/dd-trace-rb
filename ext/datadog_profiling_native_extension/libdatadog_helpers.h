#pragma once

#include <datadog/profiling.h>
#include "ruby_helpers.h"

typedef struct ddog_prof_Profile {
  struct ddog_prof_Profile *inner;
} ddog_prof_Profile;
typedef struct ddog_prof_ManagedStringId {
  uint32_t value;
} ddog_prof_ManagedStringId;

typedef struct ddog_prof_ManagedStringStorage {
  const void *inner;
} ddog_prof_ManagedStringStorage;

typedef struct ddog_prof_Label {
  ddog_CharSlice key;
  struct ddog_prof_ManagedStringId key_id;
  /**
   * At most one of the following must be present
   */
  ddog_CharSlice str;
  struct ddog_prof_ManagedStringId str_id;
  int64_t num;
  /**
   * Should only be present when num is present.
   * Specifies the units of num.
   * Use arbitrary string (for example, "requests") as a custom count unit.
   * If no unit is specified, consumer may apply heuristic to deduce the unit.
   * Consumers may also  interpret units like "bytes" and "kilobytes" as memory
   * units and units like "seconds" and "nanoseconds" as time units,
   * and apply appropriate unit conversions to these.
   */
  ddog_CharSlice num_unit;
  struct ddog_prof_ManagedStringId num_unit_id;
} ddog_prof_Label;

typedef struct ddog_prof_Slice_Label {
  /**
   * Should be non-null and suitably aligned for the underlying type. It is
   * allowed but not recommended for the pointer to be null when the len is
   * zero.
   */
  const struct ddog_prof_Label *ptr;
  /**
   * The number of elements (not bytes) that `.ptr` points to. Must be less
   * than or equal to [isize::MAX].
   */
  uintptr_t len;
} ddog_prof_Slice_Label;

typedef struct ddog_prof_Slice_CharSlice {
  /**
   * Should be non-null and suitably aligned for the underlying type. It is
   * allowed but not recommended for the pointer to be null when the len is
   * zero.
   */
  const ddog_CharSlice *ptr;
  /**
   * The number of elements (not bytes) that `.ptr` points to. Must be less
   * than or equal to [isize::MAX].
   */
  uintptr_t len;
} ddog_prof_Slice_CharSlice;

typedef struct fixme_ddog_prof_Mapping {
  /**
   * Address at which the binary (or DLL) is loaded into memory.
   */
  uint64_t memory_start;
  /**
   * The limit of the address range occupied by this mapping.
   */
  uint64_t memory_limit;
  /**
   * Offset in the binary that corresponds to the first mapped address.
   */
  uint64_t file_offset;
  /**
   * The object this entry is loaded from.  This can be a filename on
   * disk for the main binary and shared libraries, or virtual
   * abstractions like "[vdso]".
   */
  ddog_CharSlice filename;
  struct ddog_prof_ManagedStringId filename_id;
  /**
   * A string that uniquely identifies a particular program version
   * with high probability. E.g., for binaries generated by GNU tools,
   * it could be the contents of the .note.gnu.build-id field.
   */
  ddog_CharSlice build_id;
  struct ddog_prof_ManagedStringId build_id_id;
} fixme_ddog_prof_Mapping;

typedef struct fixme_ddog_prof_Function {
  /**
   * Name of the function, in human-readable form if available.
   */
  ddog_CharSlice name;
  struct ddog_prof_ManagedStringId name_id;
  /**
   * Name of the function, as identified by the system.
   * For instance, it can be a C++ mangled name.
   */
  ddog_CharSlice system_name;
  struct ddog_prof_ManagedStringId system_name_id;
  /**
   * Source file containing the function.
   */
  ddog_CharSlice filename;
  struct ddog_prof_ManagedStringId filename_id;
} fixme_ddog_prof_Function;
typedef struct fixme_ddog_prof_Location {
  /**
   * todo: how to handle unknown mapping?
   */
  struct fixme_ddog_prof_Mapping mapping;
  struct fixme_ddog_prof_Function function;
  /**
   * The instruction address for this location, if available.  It
   * should be within [Mapping.memory_start...Mapping.memory_limit]
   * for the corresponding mapping. A non-leaf address may be in the
   * middle of a call instruction. It is up to display tools to find
   * the beginning of the instruction if necessary.
   */
  uint64_t address;
  int64_t line;
} fixme_ddog_prof_Location;

typedef struct ddog_prof_Slice_Location {
  /**
   * Should be non-null and suitably aligned for the underlying type. It is
   * allowed but not recommended for the pointer to be null when the len is
   * zero.
   */
  const struct fixme_ddog_prof_Location *ptr;
  /**
   * The number of elements (not bytes) that `.ptr` points to. Must be less
   * than or equal to [isize::MAX].
   */
  uintptr_t len;
} ddog_prof_Slice_Location;

typedef struct ddog_prof_Slice_ManagedStringId {
  /**
   * Should be non-null and suitably aligned for the underlying type. It is
   * allowed but not recommended for the pointer to be null when the len is
   * zero.
   */
  const struct ddog_prof_ManagedStringId *ptr;
  /**
   * The number of elements (not bytes) that `.ptr` points to. Must be less
   * than or equal to [isize::MAX].
   */
  uintptr_t len;
} ddog_prof_Slice_ManagedStringId;

typedef enum ddog_prof_Option_Error_Tag {
  DDOG_PROF_OPTION_ERROR_SOME_ERROR,
  DDOG_PROF_OPTION_ERROR_NONE_ERROR,
} ddog_prof_Option_Error_Tag;

typedef struct ddog_prof_Option_Error {
  ddog_prof_Option_Error_Tag tag;
  union {
    struct {
      struct ddog_Error some;
    };
  };
} ddog_prof_Option_Error;

typedef struct ddog_prof_Option_Error ddog_prof_MaybeError;

typedef enum ddog_prof_ManagedStringStorageInternResult_Tag {
  DDOG_PROF_MANAGED_STRING_STORAGE_INTERN_RESULT_OK,
  DDOG_PROF_MANAGED_STRING_STORAGE_INTERN_RESULT_ERR,
} ddog_prof_ManagedStringStorageInternResult_Tag;

typedef struct ddog_prof_ManagedStringStorageInternResult {
  ddog_prof_ManagedStringStorageInternResult_Tag tag;
  union {
    struct {
      struct ddog_prof_ManagedStringId ok;
    };
    struct {
      struct ddog_Error err;
    };
  };
} ddog_prof_ManagedStringStorageInternResult;

typedef struct fixme_ddog_prof_ValueType {
  ddog_CharSlice type_;
  ddog_CharSlice unit;
} fixme_ddog_prof_ValueType;

typedef enum ddog_prof_ManagedStringStorageNewResult_Tag {
  DDOG_PROF_MANAGED_STRING_STORAGE_NEW_RESULT_OK,
  DDOG_PROF_MANAGED_STRING_STORAGE_NEW_RESULT_ERR,
} ddog_prof_ManagedStringStorageNewResult_Tag;

typedef struct ddog_prof_ManagedStringStorageNewResult {
  ddog_prof_ManagedStringStorageNewResult_Tag tag;
  union {
    struct {
      struct ddog_prof_ManagedStringStorage ok;
    };
    struct {
      struct ddog_Error err;
    };
  };
} ddog_prof_ManagedStringStorageNewResult;

typedef enum ddog_prof_Profile_SerializeResult_Tag {
  DDOG_PROF_PROFILE_SERIALIZE_RESULT_OK,
  DDOG_PROF_PROFILE_SERIALIZE_RESULT_ERR,
} ddog_prof_Profile_SerializeResult_Tag;

typedef struct ddog_prof_Profile_SerializeResult {
  ddog_prof_Profile_SerializeResult_Tag tag;
  union {
    struct {
      struct ddog_prof_EncodedProfile ok;
    };
    struct {
      struct ddog_Error err;
    };
  };
} ddog_prof_Profile_SerializeResult;

typedef struct fixme_ddog_prof_Slice_ValueType {
  /**
   * Should be non-null and suitably aligned for the underlying type. It is
   * allowed but not recommended for the pointer to be null when the len is
   * zero.
   */
  const struct fixme_ddog_prof_ValueType *ptr;
  /**
   * The number of elements (not bytes) that `.ptr` points to. Must be less
   * than or equal to [isize::MAX].
   */
  uintptr_t len;
} fixme_ddog_prof_Slice_ValueType;

typedef enum ddog_prof_Profile_NewResult_Tag {
  DDOG_PROF_PROFILE_NEW_RESULT_OK,
  DDOG_PROF_PROFILE_NEW_RESULT_ERR,
} ddog_prof_Profile_NewResult_Tag;

typedef struct ddog_prof_Profile_NewResult {
  ddog_prof_Profile_NewResult_Tag tag;
  union {
    struct {
      struct ddog_prof_Profile ok;
    };
    struct {
      struct ddog_Error err;
    };
  };
} ddog_prof_Profile_NewResult;

typedef enum ddog_prof_Profile_Result_Tag {
  DDOG_PROF_PROFILE_RESULT_OK,
  DDOG_PROF_PROFILE_RESULT_ERR,
} ddog_prof_Profile_Result_Tag;

typedef struct ddog_prof_Profile_Result {
  ddog_prof_Profile_Result_Tag tag;
  union {
    struct {
      /**
       * Do not use the value of Ok. This value only exists to overcome
       * Rust -> C code generation.
       */
      bool ok;
    };
    struct {
      struct ddog_Error err;
    };
  };
} ddog_prof_Profile_Result;

void fixme_ddog_prof_Profile_drop(struct ddog_prof_Profile *profile);

DDOG_CHECK_RETURN
struct ddog_prof_ManagedStringStorageNewResult ddog_prof_ManagedStringStorage_new(void);

/**
 * TODO: @ivoanjo Should this take a `*mut ManagedStringStorage` like Profile APIs do?
 */
 void ddog_prof_ManagedStringStorage_drop(struct ddog_prof_ManagedStringStorage storage);

 typedef struct ddog_prof_Period {
  struct fixme_ddog_prof_ValueType type_;
  int64_t value;
} ddog_prof_Period;

 /**
 * Same as `ddog_profile_new` but also configures a `string_storage` for the profile.
 * TODO: @ivoanjo Should this take a `*mut ManagedStringStorage` like Profile APIs do?
 */
DDOG_CHECK_RETURN
struct ddog_prof_Profile_NewResult ddog_prof_Profile_with_string_storage(
  struct fixme_ddog_prof_Slice_ValueType sample_types,
                                                                         const struct ddog_prof_Period *period,
                                                                         struct ddog_prof_ManagedStringStorage string_storage
);

typedef struct ddog_prof_Sample {
  /**
   * The leaf is at locations[0].
   */
  struct ddog_prof_Slice_Location locations;
  /**
   * The type and unit of each value is defined by the corresponding
   * entry in Profile.sample_type. All samples must have the same
   * number of values, the same as the length of Profile.sample_type.
   * When aggregating multiple samples into a single sample, the
   * result has a list of values that is the element-wise sum of the
   * lists of the originals.
   */
  struct ddog_Slice_I64 values;
  /**
   * label includes additional context for this sample. It can include
   * things like a thread id, allocation size, etc
   */
  struct ddog_prof_Slice_Label labels;
} ddog_prof_Sample;

/**
 * # Safety
 * The `profile` ptr must point to a valid Profile object created by this
 * module. All pointers inside the `sample` need to be valid for the duration
 * of this call.
 *
 * If successful, it returns the Ok variant.
 * On error, it holds an error message in the error variant.
 *
 * # Safety
 * The `profile` ptr must point to a valid Profile object created by this
 * module.
 * This call is _NOT_ thread-safe.
 */
 DDOG_CHECK_RETURN
 struct ddog_prof_Profile_Result ddog_prof_Profile_add(struct ddog_prof_Profile *profile,
                                                       struct ddog_prof_Sample sample,
                                                       int64_t timestamp);

/**
 * Associate an endpoint to a given local root span id.
 * During the serialization of the profile, an endpoint label will be added
 * to all samples that contain a matching local root span id label.
 *
 * Note: calling this API causes the "trace endpoint" and "local root span id" strings
 * to be interned, even if no matching sample is found.
 *
 * # Arguments
 * * `profile` - a reference to the profile that will contain the samples.
 * * `local_root_span_id`
 * * `endpoint` - the value of the endpoint label to add for matching samples.
 *
 * # Safety
 * The `profile` ptr must point to a valid Profile object created by this
 * module.
 * This call is _NOT_ thread-safe.
 */
 DDOG_CHECK_RETURN
 struct ddog_prof_Profile_Result ddog_prof_Profile_set_endpoint(struct ddog_prof_Profile *profile,
                                                                uint64_t local_root_span_id,
                                                                ddog_CharSlice endpoint);


/**
 * Resets all data in `profile` except the sample types and period. Returns
 * true if it successfully reset the profile and false otherwise. The profile
 * remains valid if false is returned.
 *
 * # Arguments
 * * `profile` - A mutable reference to the profile to be reset.
 * * `start_time` - The time of the profile (after reset). Pass None/null to use the current time.
 *
 * # Safety
 * The `profile` must meet all the requirements of a mutable reference to the profile. Given this
 * can be called across an FFI boundary, the compiler cannot enforce this.
 * If `time` is not null, it must point to a valid Timespec object.
 */
 DDOG_CHECK_RETURN
 struct ddog_prof_Profile_Result ddog_prof_Profile_reset(struct ddog_prof_Profile *profile);


/**
 * Serialize the aggregated profile.
 * Drains the data, and then resets the profile for future use.
 *
 * Don't forget to clean up the ok with `ddog_prof_EncodedProfile_drop` or
 * the error variant with `ddog_Error_drop` when you are done with them.
 *
 * # Arguments
 * * `profile` - a reference to the profile being serialized.
 * * `start_time` - optional start time for the serialized profile. If None/null is passed, the
 *   time of profile creation will be used.
 * * `end_time` - optional end time of the profile. If None/null is passed, the current time will
 *   be used.
 *
 * # Safety
 * The `profile` must point to a valid profile object.
 * The `start_time` and `end_time` must be null or otherwise point to a valid TimeSpec object.
 */
 DDOG_CHECK_RETURN
 struct ddog_prof_Profile_SerializeResult ddog_prof_Profile_serialize(struct ddog_prof_Profile *profile,
                                                                      const struct ddog_Timespec *start_time,
                                                                      const struct ddog_Timespec *end_time);



 static inline VALUE ruby_string_from_vec_u8(ddog_Vec_U8 string) {
  return rb_str_new((char *) string.ptr, string.len);
}

// Utility function to be able to extract an error cstring from a ddog_Error.
// Returns the amount of characters written to string (which are necessarily
// bounded by capacity - 1 since the string will be null-terminated).
size_t read_ddogerr_string_and_drop(ddog_Error *error, char *string, size_t capacity);

// Used for pretty printing this Ruby enum. Returns "T_UNKNOWN_OR_MISSING_RUBY_VALUE_TYPE_ENTRY" for unknown elements.
// In practice, there's a few types that the profiler will probably never encounter, but I've added all entries of
// ruby_value_type that Ruby uses so that we can also use this for debugging.
const char *ruby_value_type_to_string(enum ruby_value_type type);
ddog_CharSlice ruby_value_type_to_char_slice(enum ruby_value_type type);

ddog_prof_ManagedStringId intern_or_raise(ddog_prof_ManagedStringStorage string_storage, ddog_CharSlice string);

NORETURN(void intern_all_or_raise(
  ddog_prof_ManagedStringStorage string_storage,
  ddog_prof_Slice_CharSlice strings,
  ddog_prof_ManagedStringId *output_ids,
  uintptr_t output_ids_size
));
