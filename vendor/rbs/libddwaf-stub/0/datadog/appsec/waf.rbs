module Datadog
  module AppSec
    # rubocop:disable Metrics/ModuleLength
    module WAF
      type known_addresses = ::Array[::String]
      type diagnostics = ::Hash[::String, untyped]
      type input = nil | bool | ::String | ::Symbol | ::Integer | ::Float | ::Array[input] | ::Hash[input, input]
      type result = {
        "keep" => bool,
        "events" => events,
        "actions" => actions,
        "attributes" => attributes,
        "timeout" => bool,
        # NOTE: Schema defines it as a `number`, but we alway get it as `Integer`
        #       That will be fixed in the libddwaf specs
        "duration" => ::Integer
      }
      type events = ::Array[event]
      type event = {"rule" => rule, "rule_matches" => ::Array[rule_match]}
      type rule = {
        "id" => ::String,
        "name" => ::String,
        "tags" => {
          "type" => ::String,
          # optional key
          "category" => ::String?
        },
        # optional key
        "on_match" => ::Array[::String]?
      }
      type rule_match = {
        "operator" => ::String,
        "operator_value" => ::String,
        "parameters" => ::Array[rule_match_parameter]
      }
      type rule_match_parameter = {
        "address" => ::String,
        "key_path" => ::Array[::String | ::Integer],
        "value" => ::String,
        "highlight" => ::Array[::String]
      }
      type actions = ::Hash[::String, action]
      type action = ::Hash[::String, ::String]
      type attributes = ::Hash[::String, opaque]
      type opaque = nil | bool | ::String | ::Integer | ::Float | ::Array[opaque] | ::Hash[::String, opaque]

      # retain logging proc if set properly
      self.@log_callback: untyped

      self.@logger: untyped

      def self.version: () -> untyped

      # rubocop:disable Metrics/MethodLength,Metrics/CyclomaticComplexity,Metrics/PerceivedComplexity
      def self.ruby_to_object: (untyped val, ?max_container_size: untyped?, ?max_container_depth: untyped?, ?max_string_length: untyped?, ?coerce: bool) -> untyped

      def self.object_to_ruby: (untyped obj) -> untyped

      def self.log_callback: (untyped level, untyped func, untyped file, untyped line, untyped message, untyped len) -> (nil | untyped)

      def self.logger: () -> untyped

      def self.logger=: (untyped logger) -> untyped

      RESULT_CODE: { ddwaf_err_internal: :err_internal, ddwaf_err_invalid_object: :err_invalid_object, ddwaf_err_invalid_argument: :err_invalid_argument, ddwaf_ok: :ok, ddwaf_match: :match }

      module LibDDWAF
        class Object
        end

        DDWAF_RUN_TIMEOUT: untyped
      end

      class Error < StandardError
      end

      class InstanceFinalizedError < Error
      end

      class ConversionError < Error
      end

      class LibDDWAFError < Error
        attr_reader diagnostics: untyped

        def initialize: (::String msg, ?diagnostics: untyped?) -> void
      end

      class HandleBuilder
        @builder_ptr: ::FFI::Pointer

        def initialize: (?limits: ::Hash[::Symbol, ::Integer], ?obfuscator: ::Hash[::Symbol, ::String]) -> void

        def finalize!: () -> void

        def build_handle: () -> Handle

        def add_or_update_config: (untyped config, path: ::String) -> untyped

        def remove_config_at_path: (::String path) -> bool

        private

        def ensure_pointer_presence!: () -> void
      end

      class Handle
        @handle_ptr: ::FFI::Pointer

        def initialize: (::FFI::Pointer handle_ptr) -> void

        def finalize!: () -> void

        def build_context: () -> Context

        def known_addresses: () -> WAF::known_addresses

        private

        def ensure_pointer_presence!: () -> void
      end

      class Result
        @status: ::Symbol

        @events: WAF::events

        @actions: WAF::actions

        @attributes: WAF::attributes

        @duration: ::Integer

        @timeout: bool

        @keep: bool

        @input_truncated: bool

        attr_reader status: ::Symbol

        attr_reader events: WAF::events

        attr_reader actions: WAF::actions

        attr_reader attributes: WAF::attributes

        attr_reader duration: ::Integer

        def initialize: (
          status: ::Symbol,
          events: WAF::events,
          actions: WAF::actions,
          attributes: WAF::attributes,
          duration: ::Integer,
          timeout: bool,
          keep: bool
        ) -> void

        def mark_input_truncated!: () -> bool

        def timeout?: () -> bool

        def keep?: () -> bool

        def input_truncated?: () -> bool

        def to_h: () -> ::Hash[::Symbol, (::Symbol | WAF::opaque)]
      end

      class Context
        @context_ptr: ::FFI::Pointer

        @retained: Array[untyped]

        RESULT_CODE: ::Hash[::Symbol, ::Symbol]

        def initialize: (::FFI::Pointer context_ptr) -> void

        def finalize!: () -> void

        def run: (WAF::input persistent_data, WAF::input ephemeral_data, ?::Integer timeout) -> Result

        private

        def ensure_pointer_presence!: () -> void

        def retained: () -> Array[untyped]

        def retain: (top object) -> void

        def release: (top object) -> void
      end
    end
  end
end
