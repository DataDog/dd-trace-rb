# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/elastic-transport/all/elastic-transport.rbi
#
# elastic-transport-8.0.0

module Elastic
end
module Elastic::Loggable
  def log_debug(message); end
  def log_error(message); end
  def log_fatal(message); end
  def log_info(message); end
  def log_warn(message); end
end
module Elastic::Transport
end
module Elastic::Transport::Transport
end
module Elastic::Transport::Transport::Serializer
end
module Elastic::Transport::Transport::Serializer::Base
  def initialize(transport = nil); end
end
class Elastic::Transport::Transport::Serializer::MultiJson
  def dump(object, options = nil); end
  def load(string, options = nil); end
  include Elastic::Transport::Transport::Serializer::Base
end
class Elastic::Transport::Transport::Sniffer
  def hosts; end
  def initialize(transport); end
  def parse_address_port(publish_address); end
  def parse_publish_address(publish_address); end
  def perform_sniff_request; end
  def timeout; end
  def timeout=(arg0); end
  def transport; end
end
class Elastic::Transport::Transport::Response
  def body; end
  def headers; end
  def initialize(status, body, headers = nil); end
  def status; end
end
class Elastic::Transport::Transport::Error < StandardError
end
class Elastic::Transport::Transport::SnifferTimeoutError < Timeout::Error
end
class Elastic::Transport::Transport::ServerError < Elastic::Transport::Transport::Error
end
module Elastic::Transport::Transport::Errors
end
class Elastic::Transport::Transport::Errors::MultipleChoices < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::MovedPermanently < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::Found < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::SeeOther < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::NotModified < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::UseProxy < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::TemporaryRedirect < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::PermanentRedirect < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::BadRequest < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::Unauthorized < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::PaymentRequired < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::Forbidden < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::NotFound < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::MethodNotAllowed < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::NotAcceptable < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::ProxyAuthenticationRequired < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::RequestTimeout < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::Conflict < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::Gone < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::LengthRequired < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::PreconditionFailed < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::RequestEntityTooLarge < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::RequestURITooLong < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::UnsupportedMediaType < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::RequestedRangeNotSatisfiable < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::ExpectationFailed < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::ImATeapot < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::TooManyConnectionsFromThisIP < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::UpgradeRequired < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::TooManyRequests < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::BlockedByWindowsParentalControls < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::RequestHeaderTooLarge < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::HTTPToHTTPS < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::ClientClosedRequest < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::InternalServerError < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::NotImplemented < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::BadGateway < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::ServiceUnavailable < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::GatewayTimeout < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::HTTPVersionNotSupported < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::VariantAlsoNegotiates < Elastic::Transport::Transport::ServerError
end
class Elastic::Transport::Transport::Errors::NotExtended < Elastic::Transport::Transport::ServerError
end
module Elastic::Transport::Transport::Base
  def __build_connection(host, options = nil, block = nil); end
  def __build_connections; end
  def __close_connections; end
  def __connections_from_host; end
  def __convert_to_json(o = nil, options = nil); end
  def __full_url(host); end
  def __log_response(method, path, params, body, url, response, json, took, duration); end
  def __raise_transport_error(response); end
  def __rebuild_connections(arguments = nil); end
  def __trace(method, path, params, headers, body, url, response, json, took, duration); end
  def apply_headers(client, options); end
  def compress_request(body, headers); end
  def connection_headers(connection); end
  def connections; end
  def counter; end
  def decompress_response(body); end
  def find_value(hash, regex); end
  def get_connection(options = nil); end
  def gzipped?(body); end
  def host_unreachable_exceptions; end
  def hosts; end
  def initialize(arguments = nil, &block); end
  def last_request_at; end
  def logger; end
  def logger=(arg0); end
  def options; end
  def perform_request(method, path, params = nil, body = nil, headers = nil, opts = nil, &block); end
  def protocol; end
  def reload_after; end
  def reload_after=(arg0); end
  def reload_connections!; end
  def reload_connections; end
  def reload_connections=(arg0); end
  def resurrect_after; end
  def resurrect_after=(arg0); end
  def resurrect_dead_connections!; end
  def serializer; end
  def serializer=(arg0); end
  def sniffer; end
  def sniffer=(arg0); end
  def tracer; end
  def tracer=(arg0); end
  def use_compression?; end
  def user_agent_header(client); end
  include Elastic::Loggable
end
module Elastic::Transport::Transport::Connections
end
module Elastic::Transport::Transport::Connections::Selector
end
module Elastic::Transport::Transport::Connections::Selector::Base
  def connections; end
  def initialize(arguments = nil); end
  def select(options = nil); end
end
class Elastic::Transport::Transport::Connections::Selector::Random
  def select(options = nil); end
  include Elastic::Transport::Transport::Connections::Selector::Base
end
class Elastic::Transport::Transport::Connections::Selector::RoundRobin
  def initialize(arguments = nil); end
  def select(options = nil); end
  include Elastic::Transport::Transport::Connections::Selector::Base
end
class Elastic::Transport::Transport::Connections::Connection
  def ==(other); end
  def alive!; end
  def connection; end
  def dead!; end
  def dead?; end
  def dead_since; end
  def failures; end
  def full_path(path, params = nil); end
  def full_url(path, params = nil); end
  def healthy!; end
  def host; end
  def initialize(arguments = nil); end
  def options; end
  def resurrect!; end
  def resurrectable?; end
  def to_s; end
  def verified; end
  def verified=(arg0); end
end
class Elastic::Transport::Transport::Connections::Collection
  def [](*args); end
  def add(connections); end
  def alive; end
  def all; end
  def connections; end
  def dead; end
  def each(&block); end
  def get_connection(options = nil); end
  def hosts; end
  def initialize(arguments = nil); end
  def remove(connections); end
  def selector; end
  def size; end
  def slice(*args); end
  include Enumerable
end
module Elastic::Transport::Transport::HTTP
end
class Elastic::Transport::Transport::HTTP::Faraday
  def __build_connection(host, options = nil, block = nil); end
  def host_unreachable_exceptions; end
  def perform_request(method, path, params = nil, body = nil, headers = nil, opts = nil); end
  def user_agent_header(client); end
  include Elastic::Transport::Transport::Base
end
module Elastic::Transport::MetaHeader
  def called_from?(service); end
  def client_meta_version(version); end
  def elasticsearch?; end
  def enterprise_search?; end
  def meta_header_adapter; end
  def meta_header_engine; end
  def meta_header_service_version; end
  def set_meta_header; end
end
class Elastic::Transport::Client
  def __auto_detect_adapter; end
  def __extract_hosts(hosts_config); end
  def __parse_host(host); end
  def add_header(header); end
  def initialize(arguments = nil, &block); end
  def perform_request(*args); end
  def transport; end
  def transport=(arg0); end
  def validate_ca_fingerprints; end
  include Elastic::Transport::MetaHeader
end
class Elastic::Transport::Redacted < Hash
  def initialize(elements = nil); end
  def inspect; end
  def redact(k, v, method); end
  def redacted_string(method); end
  def to_s; end
end
