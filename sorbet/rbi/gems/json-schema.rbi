# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/json-schema/all/json-schema.rbi
#
# json-schema-2.8.1

class ArraySet < Array
  def convert_to_float_if_numeric(value); end
  def include?(obj); end
end
module JSON
end
module JSON::Util
end
module JSON::Util::URI
  def self.absolutize_ref(ref, base); end
  def self.clear_cache; end
  def self.file_uri(uri); end
  def self.normalize_ref(ref, base); end
  def self.normalized_uri(uri, base_path = nil); end
  def self.parse(uri); end
  def self.strip_fragment(uri); end
  def self.unescape_uri(uri); end
  def self.unescaped_path(uri); end
end
class JSON::Schema
  def initialize(schema, uri, parent_validator = nil); end
  def schema; end
  def schema=(arg0); end
  def self.stringify(schema); end
  def to_array_schema; end
  def to_s; end
  def uri; end
  def uri=(arg0); end
  def validate(data, fragments, processor, options = nil); end
  def validator; end
  def validator=(arg0); end
end
class JSON::Schema::ReadError < StandardError
  def initialize(location, type); end
  def location; end
  def type; end
  def type_string; end
end
class JSON::Schema::ReadRefused < JSON::Schema::ReadError
  def error_message; end
end
class JSON::Schema::ReadFailed < JSON::Schema::ReadError
  def error_message; end
end
class JSON::Schema::Reader
  def accept_file?(pathname); end
  def accept_uri?(uri); end
  def initialize(options = nil); end
  def read(location); end
  def read_file(pathname); end
  def read_uri(uri); end
end
class JSON::Schema::SchemaError < StandardError
end
class JSON::Schema::SchemaParseError < JSON::ParserError
end
class JSON::Schema::JsonLoadError < StandardError
end
class JSON::Schema::JsonParseError < StandardError
end
class JSON::Util::UUID < Struct
  def <=>(other); end
  def ==(other); end
  def guid; end
  def raw_bytes; end
  def raw_bytes=(_); end
  def self.[](*arg0); end
  def self.create(clock = nil, time = nil, mac_addr = nil); end
  def self.create_md5(str, namespace); end
  def self.create_random; end
  def self.create_sha1(str, namespace); end
  def self.create_v1(clock = nil, time = nil, mac_addr = nil); end
  def self.create_v3(str, namespace); end
  def self.create_v4; end
  def self.create_v5(str, namespace); end
  def self.inspect; end
  def self.mask(v, str); end
  def self.mask18(v, str); end
  def self.mask19(v, str); end
  def self.members; end
  def self.new(*arg0); end
  def self.pack(tl, tm, th, ch, cl, n); end
  def self.parse(obj); end
  def self.read_state(fp); end
  def self.write_state(fp, c, m); end
  def to_i; end
  def to_int; end
  def to_s; end
  def to_uri; end
  def unpack; end
  def urn; end
  def version; end
  include Comparable
end
class JSON::Validator
  def build_schemas(parent_schema); end
  def custom_open(uri); end
  def fake_uuid(schema); end
  def handle_schema(parent_schema, obj); end
  def initialize(schema_data, data, opts = nil); end
  def initialize_data(data); end
  def initialize_schema(schema); end
  def load_ref_schema(parent_schema, ref); end
  def schema_from_fragment(base_schema, fragment); end
  def self.add_schema(schema); end
  def self.cache_schemas=(val); end
  def self.clear_cache; end
  def self.default_validator; end
  def self.deregister_format_validator(format, versions = nil); end
  def self.fully_validate(schema, data, opts = nil); end
  def self.fully_validate_json(schema, data, opts = nil); end
  def self.fully_validate_schema(schema, opts = nil); end
  def self.fully_validate_uri(schema, data, opts = nil); end
  def self.json_backend; end
  def self.json_backend=(backend); end
  def self.merge_missing_values(source, destination); end
  def self.parse(s); end
  def self.register_default_validator(v); end
  def self.register_format_validator(format, validation_proc, versions = nil); end
  def self.register_validator(v); end
  def self.restore_default_formats(versions = nil); end
  def self.schema_for_uri(uri); end
  def self.schema_key_for(uri); end
  def self.schema_loaded?(schema_uri); end
  def self.schema_reader; end
  def self.schema_reader=(reader); end
  def self.schemas; end
  def self.validate!(schema, data, opts = nil); end
  def self.validate(schema, data, opts = nil); end
  def self.validate2(schema, data, opts = nil); end
  def self.validate_json!(schema, data, opts = nil); end
  def self.validate_json(schema, data, opts = nil); end
  def self.validate_uri!(schema, data, opts = nil); end
  def self.validate_uri(schema, data, opts = nil); end
  def self.validator_for(schema_uri); end
  def self.validator_for_name(schema_name, raise_not_found = nil); end
  def self.validator_for_uri(schema_uri, raise_not_found = nil); end
  def self.validators; end
  def serialize(schema); end
  def validate; end
  def validation_error(error); end
  def validation_errors; end
end
class JSON::Schema::ValidationError < StandardError
  def failed_attribute; end
  def failed_attribute=(arg0); end
  def fragments; end
  def fragments=(arg0); end
  def initialize(message, fragments, failed_attribute, schema); end
  def message; end
  def message=(arg0); end
  def message_with_schema; end
  def schema; end
  def schema=(arg0); end
  def sub_errors; end
  def sub_errors=(arg0); end
  def to_hash; end
  def to_string(subschema_level = nil); end
end
class JSON::Schema::Attribute
  def self.build_fragment(fragments); end
  def self.data_valid_for_type?(data, type); end
  def self.type_of_data(data); end
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
  def self.validation_error(processor, message, fragments, current_schema, failed_attribute, record_errors); end
  def self.validation_errors(validator); end
end
class JSON::Schema::RefAttribute < JSON::Schema::Attribute
  def self.get_referenced_uri_and_schema(s, current_schema, validator); end
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::ExtendsAttribute < JSON::Schema::Attribute
  def self.get_extended_uri_and_schema(s, current_schema, validator); end
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::AdditionalPropertiesAttribute < JSON::Schema::Attribute
  def self.remove_valid_properties(extra_properties, current_schema, validator); end
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::ItemsAttribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::DependenciesAttribute < JSON::Schema::Attribute
  def self.accept_value?(value); end
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
  def self.validate_dependency(schema, data, property, value, fragments, processor, attribute, options); end
end
class JSON::Schema::EnumAttribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::MaxDecimalAttribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::FormatAttribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::DateFormat < JSON::Schema::FormatAttribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::DateTimeV4Format < JSON::Schema::FormatAttribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::DateTimeFormat < JSON::Schema::FormatAttribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::IPFormat < JSON::Schema::FormatAttribute
  def self.ip_version; end
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::IP4Format < JSON::Schema::IPFormat
  def self.ip_version; end
end
class JSON::Schema::IP6Format < JSON::Schema::IPFormat
  def self.ip_version; end
end
class JSON::Schema::UriError < StandardError
end
class JSON::Schema::UriFormat < JSON::Schema::FormatAttribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::CustomFormatError < StandardError
end
class JSON::Schema::CustomFormat < JSON::Schema::FormatAttribute
  def initialize(validation_proc); end
  def validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::TimeFormat < JSON::Schema::FormatAttribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::AnyOfAttribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::PatternPropertiesAttribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::DivisibleByAttribute < JSON::Schema::Attribute
  def self.keyword; end
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::AllOfAttribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::NotAttribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::LimitAttribute < JSON::Schema::Attribute
  def self.acceptable_type; end
  def self.error_message(schema); end
  def self.exclusive?(schema); end
  def self.invalid?(schema, data); end
  def self.limit(schema); end
  def self.limit_name; end
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
  def self.value(data); end
end
class JSON::Schema::ItemsLimitAttribute < JSON::Schema::LimitAttribute
  def self.acceptable_type; end
  def self.value(data); end
end
class JSON::Schema::LengthLimitAttribute < JSON::Schema::LimitAttribute
  def self.acceptable_type; end
  def self.value(data); end
end
class JSON::Schema::MinLengthAttribute < JSON::Schema::LengthLimitAttribute
  def self.error_message(schema); end
  def self.limit_name; end
end
class JSON::Schema::NumericLimitAttribute < JSON::Schema::LimitAttribute
  def self.acceptable_type; end
  def self.error_message(schema); end
end
class JSON::Schema::MaximumAttribute < JSON::Schema::NumericLimitAttribute
  def self.exclusive?(schema); end
  def self.limit_name; end
end
class JSON::Schema::MinimumAttribute < JSON::Schema::NumericLimitAttribute
  def self.exclusive?(schema); end
  def self.limit_name; end
end
class JSON::Schema::MaximumInclusiveAttribute < JSON::Schema::MaximumAttribute
  def self.exclusive?(schema); end
end
class JSON::Schema::MaxItemsAttribute < JSON::Schema::ItemsLimitAttribute
  def self.error_message(schema); end
  def self.limit_name; end
end
class JSON::Schema::PropertiesLimitAttribute < JSON::Schema::LimitAttribute
  def self.acceptable_type; end
  def self.value(data); end
end
class JSON::Schema::MinPropertiesAttribute < JSON::Schema::PropertiesLimitAttribute
  def self.error_message(schema); end
  def self.limit_name; end
end
class JSON::Schema::MaxPropertiesAttribute < JSON::Schema::PropertiesLimitAttribute
  def self.error_message(schema); end
  def self.limit_name; end
end
class JSON::Schema::MinimumInclusiveAttribute < JSON::Schema::MinimumAttribute
  def self.exclusive?(schema); end
end
class JSON::Schema::MaxLengthAttribute < JSON::Schema::LengthLimitAttribute
  def self.error_message(schema); end
  def self.limit_name; end
end
class JSON::Schema::MinItemsAttribute < JSON::Schema::ItemsLimitAttribute
  def self.error_message(schema); end
  def self.limit_name; end
end
class JSON::Schema::UniqueItemsAttribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::PropertiesOptionalAttribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::PatternAttribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::MultipleOfAttribute < JSON::Schema::DivisibleByAttribute
  def self.keyword; end
end
class JSON::Schema::TypeAttribute < JSON::Schema::Attribute
  def self.list_types(types); end
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::AdditionalItemsAttribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::OneOfAttribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::RequiredAttribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::DependenciesV4Attribute < JSON::Schema::DependenciesAttribute
  def self.accept_value?(value); end
end
class JSON::Schema::TypeV4Attribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::PropertiesAttribute < JSON::Schema::Attribute
  def self.required?(schema, options); end
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::DisallowAttribute < JSON::Schema::Attribute
  def self.validate(current_schema, data, fragments, processor, validator, options = nil); end
end
class JSON::Schema::PropertiesV4Attribute < JSON::Schema::PropertiesAttribute
  def self.required?(schema, options); end
end
class JSON::Schema::Validator
  def attributes; end
  def attributes=(arg0); end
  def default_formats; end
  def extend_schema_definition(schema_uri); end
  def formats; end
  def formats=(arg0); end
  def initialize; end
  def metaschema; end
  def names; end
  def names=(arg0); end
  def uri; end
  def uri=(arg0); end
  def validate(current_schema, data, fragments, processor, options = nil); end
end
class JSON::Schema::Draft1 < JSON::Schema::Validator
  def initialize; end
end
class JSON::Schema::Draft2 < JSON::Schema::Validator
  def initialize; end
end
class JSON::Schema::Draft3 < JSON::Schema::Validator
  def initialize; end
end
class JSON::Schema::Draft4 < JSON::Schema::Validator
  def initialize; end
end
class JSON::Schema::Draft6 < JSON::Schema::Validator
  def initialize; end
end
class JSON::Schema::HyperDraft1 < JSON::Schema::Draft1
  def initialize; end
end
class JSON::Schema::HyperDraft2 < JSON::Schema::Draft2
  def initialize; end
end
class JSON::Schema::HyperDraft3 < JSON::Schema::Draft3
  def initialize; end
end
class JSON::Schema::HyperDraft4 < JSON::Schema::Draft4
  def initialize; end
end
class JSON::Schema::HyperDraft6 < JSON::Schema::Draft6
  def initialize; end
end
