#!/usr/bin/env ruby
require 'thor'

# rubocop:disable Metrics/ClassLength
# rubocop:disable Metrics/AbcSize
# rubocop:disable Metrics/PerceivedComplexity
# rubocop:disable Metrics/CyclomaticComplexity
# rubocop:disable Metrics/MethodLength

# Setup CLI for configuring Datadog tracer
class CLI < Thor
  include Thor::Actions

  Configuration = Struct.new('Configuration', :name, :key, :default, :type, :value)

  desc 'configure', 'Generate Datadog configuration file'
  option :path, :default => 'config/initializers/datadog.rb'
  option :host, :aliases => '-h'
  option :port, :type => :numeric, :aliases => '-p'
  option :debug, :type => :boolean, :aliases => '-d'
  option :startup_logs, :type => :boolean
  option :env, :aliases => '-e'
  option :service, :aliases => '-s'
  option :tags, :aliases => '-t'
  option :version, :aliases => '-v'
  option :tracing_analytics, :type => :boolean
  option :tracing_propagation_extract_style, :repeatable => true
  option :tracing_propagation_inject_style, :repeatable => true
  option :tracing_enabled, :type => :boolean
  option :tracing_log_injection, :type => :boolean
  option :tracing_partial_flush_enabled, :type => :boolean
  option :tracing_partial_flush_min_spans_threshold, :type => :numeric
  option :tracing_sampling_default_rate, :type => :numeric
  option :tracing_sampling_rate_limit, :type => :numeric
  option :tracing_report_hostname, :type => :boolean
  option :tracing_test_mode, :type => :boolean
  def configure
    block = []

    block.append("c.agent.host = '#{options.host}'") if options.key?(:host)
    block.append("c.agent.port = #{options.port}") if options.key?(:port)
    block.append("c.diagnostics.debug = #{options.debug}") if options.key?(:debug)
    block.append("c.diagnostics.startup_logs.enabled = #{options.startup_logs}") if options.key?(:startup_logs)
    block.append("c.env = '#{options.env}'") if options.key?(:env)
    block.append("c.service = '#{options.service}'") if options.key?(:service)
    block.append("c.tags = '#{options.tags}'") if options.key?(:tags)
    block.append("c.version = '#{options.version}'") if options.key?(:version)
    block.append("c.tracing.analytics.enabled = #{options.tracing_analytics}") if options.key?(:tracing_analytics)
    if options.key?(:tracing_propagation_extract_style)
      block.append(
        "c.tracing.distributed_tracing.propagation_extract_style = #{options.tracing_propagation_extract_style}"
      )
    end
    if options.key?(:tracing_propagation_inject_style)
      block.append(
        "c.tracing.distributed_tracing.tracing_propagation_inject_style = #{options.tracing_propagation_inject_style}"
      )
    end
    block.append("c.tracing.enabled = #{options.tracing_enabled}") if options.key?(:tracing_enabled)
    block.append("c.tracing.log_injection = #{options.tracing_log_injection}") if options.key?(:tracing_log_injection)
    if options.key?(:tracing_partial_flush_enabled)
      block.append("c.tracing.partial_flush.enabled = #{options.tracing_partial_flush_enabled}")
    end
    if options.key?(:tracing_partial_flush_min_spans_threshold)
      block.append("c.tracing.partial_flush.min_spans_threshold = #{options.tracing_partial_flush_min_spans_threshold}")
    end
    if options.key?(:tracing_sampling_default_rate)
      block.append("c.tracing.sampling.default_rate = #{options.tracing_sampling_default_rate}")
    end
    if options.key?(:tracing_sampling_rate_limit)
      block.append("c.tracing.sampling.rate_limit = #{options.tracing_sampling_rate_limit}")
    end
    block.append("c.tracing.report_hostname = #{options.tracing_report_hostname}") if options.key?(:tracing_report_hostname)
    block.append("c.tracing.test_mode.enabled = #{options.tracing_test_mode}") if options.key?(:tracing_test_mode)

    configuration_block = "require 'ddtrace'

Datadog.configure do |c|
  #{block.join("\n  ")}
end"
    create_file(options.path, configuration_block)
    # inject_into_file('Gemfile', "gem 'ddtrace'")
  end

  desc 'configure_interactive', 'Generate Datadog configuration file interactively'
  def configure_interactive
    path = ask('File location:', default: 'config/initializers/datadog.rb')

    basic_configuration = [
      Configuration.new('Host', 'c.agent.host', ENV.fetch('DD_AGENT_HOST', '127.0.0.1'), :string, nil),
      Configuration.new('Port', 'c.agent.port', ENV.fetch('DD_TRACE_AGENT_PORT', '8126'), :integer, nil),
      Configuration.new('Env', 'c.env', ENV['DD_ENV'], :string, nil),
      Configuration.new('Tags', 'c.tags', ENV['DD_TAGS'], :string, nil),
      Configuration.new('Version', 'c.version', ENV['DD_VERSION'], :string, nil),
    ]

    diagnostics_configuration = [
      Configuration.new('Diagnostics debug', 'c.diagnostics.debug', ENV.fetch('DD_TRACE_DEBUG', 'false'), :boolean, nil),
      Configuration.new(
        'Enable startup logs',
        'c.diagnostics.startup_logs.enabled',
        ENV['DD_TRACE_STARTUP_LOGS'],
        :boolean,
        nil
      )
    ]

    tracing_configuration = [
      Configuration.new('Tracing enabled', 'c.tracing.enabled', ENV.fetch('DD_TRACE_ENABLED', 'true'), :boolean, nil),
      Configuration.new(
        'Log injection enabled',
        'c.tracing.log_injection',
        ENV.fetch('DD_LOGS_INJECTION', 'true'),
        :boolean,
        nil
      ),
      Configuration.new(
        'Analytics enabled',
        'c.tracing.analytics.enabled',
        ENV['DD_TRACE_ANALYTICS_ENABLED'],
        :boolean,
        nil
      ),
      Configuration.new(
        'Report hostname',
        'c.tracing.report_hostname',
        ENV.fetch('DD_TRACE_REPORT_HOSTNAME', 'false'),
        :boolean,
        nil
      ),
    ]
    partial_flushing_configuration = [
      Configuration.new('Partial flushing enabled', 'c.tracing.partial_flush.enabled', 'false', :boolean, nil),
      Configuration.new(
        'Partial flushing minimum spans threshold',
        'c.tracing.partial_flush.min_spans_threshold',
        '500',
        :integer,
        nil
      ),
    ]
    sampling_configuration = [
      Configuration.new(
        'Sampling default rate',
        'c.tracing.sampling.default_rate',
        ENV['DD_TRACE_SAMPLE_RATE'],
        :float,
        nil
      ),
      Configuration.new(
        'Sampling rate limit',
        'c.tracing.sampling.rate_limit',
        ENV.fetch('DD_TRACE_RATE_LIMIT', '100'),
        :integer,
        nil
      ),
    ]
    test_mode_configuration = [
      Configuration.new(
        'Test mode enabled',
        'c.tracing.test_mode.enabled',
        ENV.fetch('DD_TRACE_TEST_MODE_ENABLED', 'false'),
        :boolean,
        nil
      ),
    ]

    configurations = [basic_configuration, diagnostics_configuration, tracing_configuration,
                      partial_flushing_configuration, sampling_configuration, test_mode_configuration]

    ask_config(basic_configuration)
    ask_config(diagnostics_configuration) if yes?('Configure diagnostics? [y/n]')
    ask_config(tracing_configuration) if yes?('Configure tracing? [y/n]')
    ask_config(partial_flushing_configuration) if yes?('Configure partial flushing? [y/n]')
    ask_config(sampling_configuration) if yes?('Configure sampling? [y/n]')
    ask_config(test_mode_configuration) if yes?('Configure test mode? [y/n]')

    block = ''
    configurations.each do |configs|
      config_block = configs.map do |config|
        "\n #{config.key} = #{cast(config)}" unless config.value.nil?
      end.join
      block += config_block
    end

    configuration_block = "require 'ddtrace'

Datadog.configure do |c|#{block}
end"

    create_file(path, configuration_block)
  end

  def self.exit_on_failure?
    true
  end

  private

  def ask_config(configuration_options)
    configuration_options.each do |configuration|
      value = ask("#{configuration.name}:", default: configuration.default)
      configuration.value = value unless value.empty?
    end
  end

  def cast(configuration)
    case configuration.type
    when :integer
      configuration.value.to_i
    when :boolean
      configuration.value == 'true'
    when :float
      configuration.value.to_f
    else
      "'#{configuration.value}'"
    end
  end
end
# rubocop:enable Metrics/ClassLength
# rubocop:enable Metrics/PerceivedComplexity
# rubocop:enable Metrics/CyclomaticComplexity
# rubocop:enable Metrics/AbcSize
# rubocop:enable Metrics/MethodLength

CLI.start(ARGV)
