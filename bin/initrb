#!/usr/bin/env ruby
require 'thor'
require 'bundler'
require 'ddtrace'

# rubocop:disable Metrics/ClassLength
# rubocop:disable Metrics/AbcSize
# rubocop:disable Metrics/MethodLength
# Setup CLI for configuring Datadog tracer
class CLI < Thor
  include Thor::Actions

  Configuration = Struct.new('Configuration', :name, :key, :default, :type, :value)

  desc 'configure', 'Generate Datadog configuration file'
  option :path, :default => 'config/initializers/datadog.rb'
  option :host, :aliases => '-h'
  option :port, :type => :numeric, :aliases => '-p'
  option :env, :aliases => '-e'
  option :service, :aliases => '-s'
  option :tags, :aliases => '-t'
  option :version, :aliases => '-v'
  def configure
    block = []

    block.append("c.agent.host = '#{options.host}'") if options.key?(:host)
    block.append("c.agent.port = #{options.port}") if options.key?(:port)
    block.append("c.env = '#{options.env}'") if options.key?(:env)
    block.append("c.service = '#{options.service}'") if options.key?(:service)
    block.append("c.tags = #{options.tags}") if options.key?(:tags)
    block.append("c.version = '#{options.version}'") if options.key?(:version)

    configuration_block = "require 'ddtrace'

Datadog.configure do |c|
  #{block.join("\n  ")}
end
"
    create_file(options.path, configuration_block)
    # inject_into_file('Gemfile', "gem 'ddtrace'")
  end

  desc 'configure_interactive', 'Generate Datadog configuration file interactively'
  def configure_interactive
    path = ask('File location:', default: 'config/initializers/datadog.rb')

    basic_configuration = [
      Configuration.new('Host', 'c.agent.host', ENV.fetch('DD_AGENT_HOST', '127.0.0.1'), :string, nil),
      Configuration.new('Port', 'c.agent.port', ENV.fetch('DD_TRACE_AGENT_PORT', '8126'), :integer, nil),
      Configuration.new('Env', 'c.env', ENV['DD_ENV'], :string, nil),
      Configuration.new('Service', 'c.service', ENV['DD_SERVICE'], :string, nil),
      Configuration.new('Tags', 'c.tags', format_tags(ENV['DD_TAGS']), :hash, nil),
      Configuration.new('Version', 'c.version', ENV['DD_VERSION'], :string, nil),
    ]

    diagnostics_configuration = [
      Configuration.new('Diagnostics debug', 'c.diagnostics.debug', ENV.fetch('DD_TRACE_DEBUG', 'false'), :boolean, nil),
      Configuration.new(
        'Enable startup logs',
        'c.diagnostics.startup_logs.enabled',
        ENV['DD_TRACE_STARTUP_LOGS'],
        :boolean,
        nil
      )
    ]

    tracing_configuration = [
      Configuration.new('Tracing enabled', 'c.tracing.enabled', ENV.fetch('DD_TRACE_ENABLED', 'true'), :boolean, nil),
      Configuration.new(
        'Log injection enabled',
        'c.tracing.log_injection',
        ENV.fetch('DD_LOGS_INJECTION', 'true'),
        :boolean,
        nil
      ),
      Configuration.new(
        'Analytics enabled',
        'c.tracing.analytics.enabled',
        ENV['DD_TRACE_ANALYTICS_ENABLED'],
        :boolean,
        nil
      ),
      Configuration.new(
        'Report hostname',
        'c.tracing.report_hostname',
        ENV.fetch('DD_TRACE_REPORT_HOSTNAME', 'false'),
        :boolean,
        nil
      ),
    ]
    partial_flushing_configuration = [
      Configuration.new('Partial flushing enabled', 'c.tracing.partial_flush.enabled', 'false', :boolean, nil),
      Configuration.new(
        'Partial flushing minimum spans threshold',
        'c.tracing.partial_flush.min_spans_threshold',
        '500',
        :integer,
        nil
      ),
    ]
    sampling_configuration = [
      Configuration.new(
        'Sampling default rate',
        'c.tracing.sampling.default_rate',
        ENV['DD_TRACE_SAMPLE_RATE'],
        :float,
        nil
      ),
      Configuration.new(
        'Sampling rate limit',
        'c.tracing.sampling.rate_limit',
        ENV.fetch('DD_TRACE_RATE_LIMIT', '100'),
        :integer,
        nil
      ),
    ]
    test_mode_configuration = [
      Configuration.new(
        'Test mode enabled',
        'c.tracing.test_mode.enabled',
        ENV.fetch('DD_TRACE_TEST_MODE_ENABLED', 'false'),
        :boolean,
        nil
      ),
    ]

    configurations = [basic_configuration, diagnostics_configuration, tracing_configuration,
                      partial_flushing_configuration, sampling_configuration, test_mode_configuration]

    ask_config(basic_configuration)
    ask_config(diagnostics_configuration) if yes?('Configure diagnostics? Press `y` to configure.')
    ask_config(tracing_configuration) if yes?('Configure tracing? Press `y` to configure.')
    ask_config(partial_flushing_configuration) if yes?('Configure partial flushing? Press `y` to configure.')
    ask_config(sampling_configuration) if yes?('Configure sampling? Press `y` to configure.')
    ask_config(test_mode_configuration) if yes?('Configure test mode? Press `y` to configure.')

    block = ''
    configurations.each do |configs|
      config_block = configs.map do |config|
        "\n  #{config.key} = #{cast_type(config)}" unless config.value.nil?
      end.join
      block += config_block
    end

    available_integrations.each do |integration|
      block += "\n  c.tracing.instrument :#{integration}" unless no?("Press `n` to skip tracing #{integration}.")
    end

    configuration_block = "require 'ddtrace'

Datadog.configure do |c|#{block}
end
"

    unless ddtrace_installed?
      say('Adding `ddtrace` to bundler...')
      add_to_bundler
    end
    say('Creating configuration file...')
    create_file(path, configuration_block)
    say('Configuration file created, happy tracing!')
  end

  def self.exit_on_failure?
    true
  end

  private

  def ask_config(configuration_options)
    configuration_options.each do |configuration|
      value = ask("#{configuration.name}:", default: configuration.default)
      configuration.value = value unless value.empty?
    end
  end

  def cast_type(configuration)
    case configuration.type
    when :integer
      configuration.value.to_i
    when :boolean
      configuration.value == 'true'
    when :float
      configuration.value.to_f
    when :hash
      configuration.value
    else
      "'#{configuration.value}'"
    end
  end

  def available_integrations
    available = []
    Datadog.registry.map do |integration|
      if integration.klass.class.compatible?
        available << integration.name
        # available[integration.name] = get_options(integration.klass)
      end
    end
    available
  end

  def add_to_bundler
    `bundle add ddtrace`
  end

  def ddtrace_installed?
    bundled_deps.include?('ddtrace')
  end

  def bundled_deps
    Bundler.definition.dependencies.map(&:name)
  end

  def format_tags(tags)
    nil if tags.nil?
    tags_map = {}
    tags.split(',').each do |tag|
      k, v = tag.split(':')
      tags_map[k] = v
    end
    tags_map
  end

  # def get_options(integration)
  #   integration.configuration.class.options.map do |key, option_def|
  #     Struct::Configuration.new(
  #       key,
  #       key,
  #       option_def.default.is_a?(Proc) ? option_def.default.call : option_def.default,
  #       :unknown,
  #       nil
  #     )
  #   end
  # end
end
# rubocop:enable Metrics/ClassLength
# rubocop:enable Metrics/AbcSize
# rubocop:enable Metrics/MethodLength

CLI.start(ARGV)
