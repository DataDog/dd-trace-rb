#!/usr/bin/env ruby
require 'thor'
require 'bundler'
require 'ddtrace'

# rubocop:disable Metrics/ClassLength
# rubocop:disable Metrics/AbcSize
# rubocop:disable Metrics/MethodLength
# Setup CLI for configuring Datadog tracer
class CLI < Thor
  include Thor::Actions

  Configuration = Struct.new('Configuration', :name, :key, :default, :type, :value)
  IntegrationOption = Struct.new('IntegrationOption', :name, :default, :type, :value)

  desc 'configure', 'Generate Datadog configuration file'
  option :path, :default => 'config/initializers/datadog.rb'
  option :host, :aliases => '-h', :default => '127.0.0.1'
  option :port, :type => :numeric, :aliases => '-p', :default => 8126
  option :env, :aliases => '-e'
  option :service, :aliases => '-s'
  option :tag, :type => :hash, :aliases => '-t', :repeatable => true
  option :version, :aliases => '-v'
  def configure
    block = []

    block.append("c.agent.host = '#{options.host}'") if options.key?(:host)
    block.append("c.agent.port = #{options.port}") if options.key?(:port)
    block.append("c.env = '#{options.env}'") if options.key?(:env)
    block.append("c.service = '#{options.service}'") if options.key?(:service)
    block.append("c.tags = #{options.tag}") if options.key?(:tag)
    block.append("c.version = '#{options.version}'") if options.key?(:version)

    configuration_block = "require 'ddtrace'\n\nDatadog.configure do |c|\n  #{block.join("\n  ")}\nend\n"
    unless ddtrace_installed?
      say('Adding `ddtrace` to bundler...')
      add_to_bundler
    end

    create_config(options.path, configuration_block)
  end

  desc 'configure_interactive', 'Generate Datadog configuration file interactively'
  def configure_interactive
    path = ask(set_color('File location:', :bold), default: 'config/initializers/datadog.rb')

    basic_configuration = [
      Configuration.new('Host', 'c.agent.host', ENV.fetch('DD_AGENT_HOST', '127.0.0.1'), :string, nil),
      Configuration.new('Port', 'c.agent.port', ENV.fetch('DD_TRACE_AGENT_PORT', '8126'), :integer, nil),
      Configuration.new('Env', 'c.env', ENV['DD_ENV'], :string, nil),
      Configuration.new('Service', 'c.service', ENV['DD_SERVICE'], :string, nil),
      Configuration.new('Tags', 'c.tags', format_tags(ENV['DD_TAGS']), :hash, nil),
      Configuration.new('Version', 'c.version', ENV['DD_VERSION'], :string, nil),
    ]

    diagnostics_configuration = [
      Configuration.new('Diagnostics debug', 'c.diagnostics.debug', ENV.fetch('DD_TRACE_DEBUG', 'false'), :boolean, nil),
      Configuration.new(
        'Enable startup logs',
        'c.diagnostics.startup_logs.enabled',
        ENV['DD_TRACE_STARTUP_LOGS'],
        :boolean,
        nil
      )
    ]

    tracing_configuration = [
      Configuration.new('Tracing enabled', 'c.tracing.enabled', ENV.fetch('DD_TRACE_ENABLED', 'true'), :boolean, nil),
      Configuration.new(
        'Log injection enabled',
        'c.tracing.log_injection',
        ENV.fetch('DD_LOGS_INJECTION', 'true'),
        :boolean,
        nil
      ),
      Configuration.new(
        'Analytics enabled',
        'c.tracing.analytics.enabled',
        ENV['DD_TRACE_ANALYTICS_ENABLED'],
        :boolean,
        nil
      ),
      Configuration.new(
        'Report hostname',
        'c.tracing.report_hostname',
        ENV.fetch('DD_TRACE_REPORT_HOSTNAME', 'false'),
        :boolean,
        nil
      ),
    ]

    partial_flushing_configuration = [
      Configuration.new('Partial flushing enabled', 'c.tracing.partial_flush.enabled', 'false', :boolean, nil),
      Configuration.new(
        'Partial flushing minimum spans threshold',
        'c.tracing.partial_flush.min_spans_threshold',
        '500',
        :integer,
        nil
      ),
    ]

    sampling_configuration = [
      Configuration.new(
        'Sampling default rate',
        'c.tracing.sampling.default_rate',
        ENV['DD_TRACE_SAMPLE_RATE'],
        :float,
        nil
      ),
      Configuration.new(
        'Sampling rate limit',
        'c.tracing.sampling.rate_limit',
        ENV.fetch('DD_TRACE_RATE_LIMIT', '100'),
        :integer,
        nil
      ),
    ]

    test_mode_configuration = [
      Configuration.new(
        'Test mode enabled',
        'c.tracing.test_mode.enabled',
        ENV.fetch('DD_TRACE_TEST_MODE_ENABLED', 'false'),
        :boolean,
        nil
      ),
    ]

    configurations = [basic_configuration, diagnostics_configuration, tracing_configuration,
                      partial_flushing_configuration, sampling_configuration, test_mode_configuration]

    ask_config(basic_configuration)
    ask_config(diagnostics_configuration) if yes?(set_color('Configure diagnostics? Press `y` to configure.', :yellow))
    ask_config(tracing_configuration) if yes?(set_color('Configure tracing? Press `y` to configure.', :yellow))
    ask_config(partial_flushing_configuration) if yes?(
      set_color(
        'Configure partial flushing? Press `y` to configure.',
        :yellow
      )
    )
    ask_config(sampling_configuration) if yes?(set_color('Configure sampling? Press `y` to configure.', :yellow))
    ask_config(test_mode_configuration) if yes?(set_color('Configure test mode? Press `y` to configure.', :yellow))

    block = ''
    configurations.each do |configs|
      config_block = configs.map do |config|
        "\n  #{config.key} = #{cast_type(config)}" unless config.value.nil?
      end.join
      block += config_block
    end

    available_integrations.each do |integration, options|
      integration_block = ''
      next if no?(set_color("Press `n` to skip tracing #{integration}.", :magenta))

      integration_block += "\n  c.tracing.instrument :#{integration}"
      ask_config(options) if yes?(set_color('Press `y` to configure options for this integration'), :yellow)
      integration_block += options.map do |option|
        ", #{option.name}: #{cast_type(option)}" unless option.value.nil? || option.default == option.value
      end.join
      block += integration_block
    end

    configuration_block = "require 'ddtrace'\n\nDatadog.configure do |c|#{block}\nend\n"
    create_config(path, configuration_block)
  end

  def self.exit_on_failure?
    true
  end

  private

  def ask_config(configuration_options)
    configuration_options.each do |configuration|
      value = ask(set_color("#{configuration.name}:", :bold), default: configuration.default)
      configuration.value = value unless value.empty?
    end
  end

  def cast_type(configuration)
    case configuration.type
    when :string
      "'#{configuration.value}'"
    when :boolean
      configuration.value == 'true'
    when :integer
      numeric?(configuration.value) ? configuration.value.to_i : configuration.default.to_i
    when :float
      numeric?(configuration.value) ? configuration.value.to_f : configuration.default.tracing_configuration
    else
      configuration.value
    end
  end

  def available_integrations
    available = {}
    registry = Datadog.registry
    registry.map do |integration|
      available[integration.name] = get_options(integration.klass) if integration.klass.class.compatible?
    end
    available
  end

  def add_to_bundler
    `bundle add ddtrace`
  end

  def ddtrace_installed?
    bundled_deps.include?('ddtrace')
  end

  def bundled_deps
    Bundler.definition.dependencies.map(&:name)
  end

  def format_tags(tags)
    return nil if tags.nil?

    tags_map = {}
    tags.split(',').each do |tag|
      k, v = tag.split(':')
      tags_map[k] = v
    end
    tags_map
  end

  def create_config(path, configuration_block)
    unless ddtrace_installed?
      say(set_color('Adding `ddtrace` to bundler...', :greeb))
      add_to_bundler
    end
    say(set_color('Creating configuration file...', :green))
    create_file(path, configuration_block)
    say(set_color('Configuration file created, happy tracing!', :green))
  end

  def get_options(integration)
    integration_options = integration.configuration.class.options
    integration_options.map do |key, option_def|
      if option_def.default.is_a?(Proc)
        default = option_def.default.call unless option_def.default.lambda?
      else
        default = option_def.default
      end
      IntegrationOption.new(key, default.to_s, get_option_type(default), nil)
    end
  end

  def get_option_type(option_default)
    return :boolean if [true, false].include?(option_default)
    return :integer if option_default.is_a?(Integer)
    return :float if option_default.is_a?(Float)

    :string
  end

  def numeric?(value)
    true if Float(value) rescue false
  end
end
# rubocop:enable Metrics/ClassLength
# rubocop:enable Metrics/AbcSize
# rubocop:enable Metrics/MethodLength

CLI.start(ARGV)
