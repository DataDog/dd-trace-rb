#!/usr/bin/env ruby
require 'thor'
require 'bundler'
require 'ddtrace'

# rubocop:disable Metrics/ClassLength
# Setup CLI for configuring Datadog tracer
class CLI < Thor
  include Thor::Actions

  # Map `ddinitrb -I` to configure interactively
  map '-I' => :configure_interactive

  Configuration = Struct.new('Configuration', :name, :key, :default, :type, :value)
  IntegrationOption = Struct.new('IntegrationOption', :name, :default, :type, :value)

  def self.exit_on_failure?
    true
  end

  def self.format_tags(tags)
    return nil if tags.nil?

    tags_map = {}
    tags.split(',').each do |tag|
      k, v = tag.split(':')
      tags_map[k] = v
    end
    tags_map
  end

  desc 'configure', 'Generate Datadog configuration file with provided flags'
  option :filepath,
    :aliases => '-f',
    :default => 'config/initializers/datadog.rb',
    :desc => 'The .rb filepath where the Datadog configuration block should be placed.'
  option :host,
    :aliases => '-h',
    :default => ENV.fetch('DD_AGENT_HOST', '127.0.0.1'),
    :desc => 'Hostname of agent to where trace data will be sent.'
  option :port,
    :type => :numeric,
    :aliases => '-p',
    :default => ENV.fetch('DD_TRACE_AGENT_PORT', '8126').to_i,
    :banner => 'PORT',
    :desc => 'Port of agent host to where trace data will be sent.'
  option :env,
    :aliases => '-e',
    :default => ENV['DD_ENV'],
    :desc => 'Your application environment. (e.g. production, staging, etc.) This value is set as a tag on all traces.'
  option :service,
    :aliases => '-s',
    :default => ENV['DD_SERVICE'],
    :desc => 'Your application\'s default service name. (e.g. billing-api) This value is set as a tag on all traces.'
  option :tag,
    :type => :hash,
    :aliases => '-t',
    :repeatable => true,
    :default => format_tags(ENV['DD_TAGS']),
    :desc => 'Custom tags in key:value pairs set on all traces. This flag can be used multiple times to set different tags.'
  option :version,
    :aliases => '-v',
    :default => ENV['DD_VERSION'],
    :desc => 'Your application version (e.g. 2.5, 202003181415, 1.3-alpha, etc.) This value is set as a tag on all traces.'
  option :instrument,
    :aliases => '-i',
    :repeatable => true,
    :desc => 'The name of the integration(s) you would like to trace. This flag can be used multiple times to trace '\
             'different integrations.'
  option :force,
    :aliases => '-F',
    :desc => 'Force overwrite of any existing configuration file.'
  def configure
    block = []

    block.append("c.agent.host = '#{options.host}'") if options.key?(:host)
    block.append("c.agent.port = #{options.port}") if options.key?(:port)
    block.append("c.env = '#{options.env}'") if options.key?(:env)
    block.append("c.service = '#{options.service}'") if options.key?(:service)
    block.append("c.tags = #{options.tag}") if options.key?(:tag)
    block.append("c.version = '#{options.version}'") if options.key?(:version)

    if options.key?(:instrument)
      options.instrument.each do |integration|
        block.append("c.tracing.instrument :#{integration}") if integrations.include?(integration)
      end
    end

    configuration_block = "require 'ddtrace'\n\nDatadog.configure do |c|\n  #{block.join("\n  ")}\nend\n"
    unless ddtrace_installed?
      say('Adding `ddtrace` to bundler...')
      add_to_bundler
    end

    create_config(options.filepath, configuration_block, options.key?(:force))
  end

  # rubocop:disable Metrics/AbcSize
  # rubocop:disable Metrics/MethodLength
  desc 'configure_interactive', 'Generate Datadog configuration file interactively'
  def configure_interactive
    basic_configuration = [
      Configuration.new('Host', 'c.agent.host', ENV.fetch('DD_AGENT_HOST', '127.0.0.1'), :string, nil),
      Configuration.new('Port', 'c.agent.port', ENV.fetch('DD_TRACE_AGENT_PORT', '8126'), :integer, nil),
      Configuration.new('Env', 'c.env', ENV['DD_ENV'], :string, nil),
      Configuration.new('Service', 'c.service', ENV['DD_SERVICE'], :string, nil),
      Configuration.new('Tags', 'c.tags', self.class.format_tags(ENV['DD_TAGS']), :hash, nil),
      Configuration.new('Version', 'c.version', ENV['DD_VERSION'], :string, nil),
    ]

    diagnostics_configuration = [
      Configuration.new('Diagnostics debug', 'c.diagnostics.debug', ENV.fetch('DD_TRACE_DEBUG', 'false'), :boolean, nil),
      Configuration.new(
        'Enable startup logs',
        'c.diagnostics.startup_logs.enabled',
        ENV['DD_TRACE_STARTUP_LOGS'],
        :boolean,
        nil
      )
    ]

    tracing_configuration = [
      Configuration.new('Tracing enabled', 'c.tracing.enabled', ENV.fetch('DD_TRACE_ENABLED', 'true'), :boolean, nil),
      Configuration.new(
        'Log injection enabled',
        'c.tracing.log_injection',
        ENV.fetch('DD_LOGS_INJECTION', 'true'),
        :boolean,
        nil
      ),
      Configuration.new(
        'Analytics enabled',
        'c.tracing.analytics.enabled',
        ENV['DD_TRACE_ANALYTICS_ENABLED'],
        :boolean,
        nil
      ),
      Configuration.new(
        'Report hostname',
        'c.tracing.report_hostname',
        ENV.fetch('DD_TRACE_REPORT_HOSTNAME', 'false'),
        :boolean,
        nil
      ),
    ]

    partial_flushing_configuration = [
      Configuration.new('Partial flushing enabled', 'c.tracing.partial_flush.enabled', 'false', :boolean, nil),
      Configuration.new(
        'Partial flushing minimum spans threshold',
        'c.tracing.partial_flush.min_spans_threshold',
        '500',
        :integer,
        nil
      ),
    ]

    sampling_configuration = [
      Configuration.new(
        'Sampling default rate',
        'c.tracing.sampling.default_rate',
        ENV['DD_TRACE_SAMPLE_RATE'],
        :float,
        nil
      ),
      Configuration.new(
        'Sampling rate limit',
        'c.tracing.sampling.rate_limit',
        ENV.fetch('DD_TRACE_RATE_LIMIT', '100'),
        :integer,
        nil
      ),
    ]

    test_mode_configuration = [
      Configuration.new(
        'Test mode enabled',
        'c.tracing.test_mode.enabled',
        ENV.fetch('DD_TRACE_TEST_MODE_ENABLED', 'false'),
        :boolean,
        nil
      ),
    ]

    block = ''

    say("\n(1/4) Basic Configuration", :on_cyan)
    path = ask(
      set_color('Tracer configuration file location:', :bold),
      default: 'config/initializers/datadog.rb',
      path: true
    )
    block += generate_block(generate_config(basic_configuration))

    say("\n(2/4) Advanced Configuration", :on_cyan)
    if yes?(
      set_color(
        'Press y if you would like to configure any advanced settings or any other key to continue.',
        :yellow,
        :bold
      )
    )
      block += generate_block(generate_config(diagnostics_configuration)) if yes?(
        set_color('Press y to configure diagnostic settings or any other key to continue.', :yellow)
      )
      block += generate_block(generate_config(tracing_configuration)) if yes?(
        set_color('Press y to configure advanced tracing settings or any other key to continue.', :yellow)
      )
      block += generate_block(generate_config(partial_flushing_configuration)) if yes?(
        set_color('Press y to configure partial flushing settings or any other key to continue.', :yellow)
      )
      block += generate_block(generate_config(sampling_configuration)) if yes?(
        set_color('Press y to configure sampling or any other key to continue.', :yellow)
      )
      block += generate_block(generate_config(test_mode_configuration)) if yes?(
        set_color('Press y to configure test mode or any other key to continue.', :yellow)
      )
    end

    say("\n(3/4) Integrations", :on_cyan)
    say('We currently instrument these installed gems:', :blue)
    print_in_columns(available_integrations.keys)
    trace_all_integrations = yes?(
      set_color(
        'Press y if you would like to configure each integration separately or any other key to automatically trace '\
        'these gems.',
        :yellow,
        :bold
      )
    )

    available_integrations.each do |integration, options|
      unless trace_all_integrations
        block += "\n  c.tracing.instrument :#{integration}"
        next
      end

      next if no?(set_color("Press n to skip or any other key to trace #{integration}.", :magenta))

      block += "\n  c.tracing.instrument :#{integration}"
      generate_config(options) if yes?(
        set_color("Press y to configure tracing settings for #{integration} or any other key to continue."), :yellow
      )
      block += options.map do |option|
        ", #{option.name}: #{cast_type(option)}" unless option.value.nil? || option.default == option.value
      end.join
    end
    block += "\n"

    say("\n(4/4) Installation and Configuration", :on_cyan)
    configuration_block = "require 'ddtrace'\n\nDatadog.configure do |c|#{block}end\n"
    create_config(path, configuration_block)
  end
  # rubocop:enable Metrics/AbcSize
  # rubocop:enable Metrics/MethodLength

  private

  def generate_block(modified_configurations)
    return '' if modified_configurations.empty?

    block = ''
    modified_configurations.each do |config|
      block += "\n  #{config.key} = #{cast_type(config)}"
    end
    block += "\n"
  end

  def generate_config(configuration_options)
    modified_configurations = []
    configuration_options.each do |configuration|
      value = ask(set_color("#{configuration.name}:", :bold), default: configuration.default)
      unless value.empty? || value == configuration.default
        configuration.value = value
        modified_configurations << configuration
      end
    end
    modified_configurations
  end

  def cast_type(configuration)
    case configuration.type
    when :string
      "'#{configuration.value}'"
    when :boolean
      configuration.value == 'true'
    when :integer
      numeric?(configuration.value) ? configuration.value.to_i : configuration.default.to_i
    when :float
      numeric?(configuration.value) ? configuration.value.to_f : configuration.default.tracing_configuration
    else
      configuration.value
    end
  end

  def available_integrations
    available = {}
    registry = Datadog.registry
    registry.map do |integration|
      available[integration.name] = get_options(integration.klass) if integration.klass.class.compatible?
    end
    available
  end

  def integrations
    Datadog.registry.map do |integration|
      integration.name.to_s
    end
  end

  def add_to_bundler
    `bundle add ddtrace`
  end

  def ddtrace_installed?
    installed = false
    Bundler.definition.dependencies.each do |dependency|
      if dependency.name == 'ddtrace'
        installed = true
        break
      end
    end
    installed
  end

  def create_config(path, configuration_block, force = false)
    unless ddtrace_installed?
      say('Adding `ddtrace` to bundler...', :green)
      add_to_bundler
    end
    say('Creating configuration file...', :green)
    create_file(path, configuration_block, { force: force })
    say(logo)
    say('Configuration file created, happy tracing!', :green)
  end

  def get_options(integration)
    integration_options = integration.configuration.class.options
    integration_options.map do |key, option_def|
      if option_def.default.is_a?(Proc)
        default = option_def.default.call unless option_def.default.lambda?
      else
        default = option_def.default
      end
      IntegrationOption.new(key, default.to_s, get_option_type(default), nil)
    end
  end

  def get_option_type(option_default)
    return :boolean if [true, false].include?(option_default)
    return :integer if option_default.is_a?(Integer)
    return :float if option_default.is_a?(Float)

    :string
  end

  def numeric?(value)
    true if Float(value) rescue false
  end

  def logo
    <<-'LOGO'
    :::::::::::::::::::::::::::::::::::::/+o/:::::::::::::::::::::::
    ::::::::::::::::::::::::::::::::::::hMMdMms:::::::::::::::::::::
    :::::::::/oydNmh/::::::::oo++/:::/sNMMMhdMMNo:::::::::::::::::::
    :::::::/dMMMMMMmMho/:+shNMMMMMNNNMMMMMMm/NMMMy::::::::::::::::::
    :::::/smMMMMMMMmdMMMMMMMMMMMMMMMMMMMMmmMo/dMMMs:::::::::::::::::
    :::::oNMMMMMMMMMsmMMMMMMMMMMMMMMMMMMMMNyo::odMm:::::::::::::::::
    :::::dMMMMMMMMMMm+MMMMMMMMMMMMMMMMMMMMMMmo::::::::::::::::::::::
    :::::/mMMMMMMMMMM/dMMMMMMMMMMMMMMMMMMMNsyms:::::::::::::::::::::
    ::::::/yMMMMMMMMm:sMMMMMMmysoyMMMMMMMMm:::m/::::::::::::::::::::
    ::::::::/ymMMMmy/:hMMMMMh:::::mMMMMMMMMmyym+::::::::::::::::::::
    :::::::::::os+++sdMMMMMMd::/osNMMMMMMMMMMMMm+:::::::::::::::::::
    :::::::::::dMMMMMMMMMMMMMNNMMMMMMMMMMMMMMMMMMs::::::::::::::::::
    :::::::::::yMMMMMMMMMMMMMMMMMMMMMMMMMMMMmdddNMy:::::::::::::::::
    :::::::::::/NMMMMMMMMMMMMMMMMMMMMMMMMN+:::::hMM/::::::::::::::::
    ::::::::::::dMMMMMMMMMMMMMMMMMMMMMMMMMmy+//hMMM/::::::::::::::::
    ::::::::::::/syMMMMMMMMMNmMMMMMMMMMMMMMMMNMMMMd:::::::::::::::::
    :::::::::::::::shMMMMMMMMmyydMMMMMMMMMMNsommdh/:/+osyhhdmo::::::
    :::::::::::::::::dMMMMMMMMMNh++shdmmdy+/syhhdmNMMMMMMMMMMy::::::
    :::::::::::::::::oMMMMMMMh/sssyyo+//+ohMMMMMMMMMMMMMMMNsMd::::::
    :::::::::::::::::sMMMMMMMd:mMMMMMMMMMMMMMMMMMMMMMMMMMN+/MN::::::
    ::::::::::::::::sMMMMMMMMM:yMMMMMMMMMMMMMMMMMddMMMMMN+::NM::::::
    ::::::::::::::omMMMMMMMMMM+oMMMMMMMMMMMMMMMMy::/odMM+:::dM+:::::
    :::::::::::/smMNNNMMMMMMMMy/MMMMMMMMMMMMMMMs:::::://::::yMo:::::
    :::::::::/yNMMMMMmdysdMMMMd:mMMMMMMddmMMMN+:::::::::::::oMy:::::
    ::::::::+NMMMMMMMMMMNs+dMMM:hMMMMMy::::/o/::::::::::::::/Md:::::
    ::::::::NMMMMMMMMMMMMMh:hMMosMMMN+:::::::::::::::::::::::Nm:::::
    ::::::::NMMMMMMMMMMMMMMs:hho/MMd/:::::::::::::/+oosyhdmNMNm:::::
    ::::::::/yNMMMMMMMMMMMMN:::::NM:::://+osyhdmNMNmdhysoo+/::::::::
    ::::::::::/hMMMMMMMMMMMM+::::hMdmNNNmdhyso++/:::::::::::::::::::
    ::::::::::::sMMMMMMMMMMm:::::+o++/::::::::::::::::::::::::::::::
    :::::::::::::odMMMMMMNh/::::::::::::::::::::::::::::::::::::::::
    :::::::::::::::/+oso+:::::::::::::::::::::::::::::::::::::::::::
    LOGO
  end
end
# rubocop:enable Metrics/ClassLength
CLI.start(ARGV)
