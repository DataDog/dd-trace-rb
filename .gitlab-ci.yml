stages:
  - manual-images
  - package
  - shared-pipeline
  - vaccine
  - macrobenchmarks
  - microbenchmarks
  - benchmarks

include:
  - remote: https://gitlab-templates.ddbuild.io/libdatadog/include/one-pipeline.yml
  - local: ".gitlab/benchmarks.yml"

variables:
  RUBY_CUSTOM_IMAGE_BASE: $DOCKER_REGISTRY/ci/dd-trace-rb/custom_ruby
  REPO_LANG: ruby # ruby is used rather that "rb"
  BUILD_JOB_NAME: save_versions

default:
  tags: ["runner:main", "size:large"]

.build-image-base:
  stage: manual-images
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" || $CI_PIPELINE_SOURCE == "push"
      changes:
        - .gitlab/Dockerfile-*
      when: manual
      allow_failure: true
  image: $DOCKER_REGISTRY/docker:20.10.13
  parallel:
    matrix:
      # ADD NEW RUBIES HERE
      - RUBY_VERSION: ["3.4", "3.3", "3.2", "3.1", "3.0", "2.7"]
  script:
    - >
      docker build
      --tag $RUBY_CUSTOM_IMAGE_BASE/$RUBY_VERSION-$ARCHITECTURE:$CI_PIPELINE_ID
      --file .gitlab/Dockerfile-$RUBY_VERSION
      .
    - docker push --all-tags $RUBY_CUSTOM_IMAGE_BASE/$RUBY_VERSION-$ARCHITECTURE

build-image-amd64:
  extends: .build-image-base
  tags: ["runner:docker"]
  variables:
    ARCHITECTURE: amd64

build-image-arm64:
  extends: .build-image-base
  tags: ["runner:docker-arm", "platform:arm64"]
  variables:
    ARCHITECTURE: arm64

promote-image:
  stage: manual-images
  when: manual
  tags: ["runner:docker"]
  image: $DOCKER_REGISTRY/docker:20.10.13
  parallel:
    matrix:
      # ADD NEW RUBIES HERE
      - RUBY_VERSION: ["3.4", "3.3", "3.2", "3.1", "3.0", "2.7"]
        ARCHITECTURE: ["amd64", "arm64"]
  script:
    - docker pull $RUBY_CUSTOM_IMAGE_BASE/$RUBY_VERSION-$ARCHITECTURE:$CI_PIPELINE_ID
    - docker tag $RUBY_CUSTOM_IMAGE_BASE/$RUBY_VERSION-$ARCHITECTURE:$CI_PIPELINE_ID $RUBY_CUSTOM_IMAGE_BASE/$RUBY_VERSION-$ARCHITECTURE:current
    - docker push $RUBY_CUSTOM_IMAGE_BASE/$RUBY_VERSION-$ARCHITECTURE:current

build-gem:
  image: $DOCKER_REGISTRY/images/mirror/ruby:3.2.2
  stage: package
  script:
    - |
      if [ -z "$CI_COMMIT_TAG" ]; then
        echo CI_JOB_ID=$CI_JOB_ID
        echo CI_COMMIT_REF_NAME=$CI_COMMIT_REF_NAME
        echo CI_COMMIT_SHA=$CI_COMMIT_SHA

        .gitlab/patch_gem_version.sh glci $CI_JOB_ID $CI_COMMIT_REF_NAME $CI_COMMIT_SHA
      fi
    - bundle install && chmod go-w -R . && bundle exec rake build
    - mkdir -p tmp && ruby -Ilib -rdatadog/version -e 'puts Gem::Version.new(Datadog::VERSION::STRING).to_s' >> tmp/version
  artifacts:
    paths:
      - pkg
      - tmp
      - lib/datadog/version.rb

install-dependencies:
  image: $RUBY_CUSTOM_IMAGE_BASE/$RUBY_VERSION-$ARCH:current
  tags: [ "arch:$ARCH" ]
  parallel:
    matrix:
      # Promote again when adding 3.4 support
      - RUBY_VERSION: ["3.3", "3.2", "3.1", "3.0", "2.7"]
        ARCH: [ "amd64", "arm64" ]
  stage: package
  needs:
    - build-gem
  script:
    - export RUBY_PACKAGE_VERSION=$(cat tmp/version)
    - export DATADOG_GEM_LOCATION=$(readlink -f pkg/datadog-*.gem)
    - ruby -v
    - gem -v
    - bundler -v
    - ruby .gitlab/install_datadog_deps.rb
  artifacts:
    paths:
      - pkg
      - tmp/$ARCH
      - lib/datadog/version.rb

package-oci:
  needs:
    - build-gem
    - install-dependencies

requirements_json_test:
  rules:
    - when: on_success
  variables:
    REQUIREMENTS_BLOCK_JSON_PATH: "lib-injection/test_block.json"
    REQUIREMENTS_ALLOW_JSON_PATH: "lib-injection/test_allow.json"

onboarding_tests_installer:
  parallel:
    matrix:
      - ONBOARDING_FILTER_WEBLOG: [test-app-ruby, test-app-ruby-container]

onboarding_tests_k8s_injection:
  parallel:
    matrix:
    - WEBLOG_VARIANT: [dd-lib-ruby-init-test-rails, dd-lib-ruby-init-test-rails-explicit,dd-lib-ruby-init-test-rails-gemsrb]
      SCENARIO: [K8S_LIB_INJECTION, K8S_LIB_INJECTION_UDS, K8S_LIB_INJECTION_NO_AC, K8S_LIB_INJECTION_NO_AC_UDS, K8S_LIB_INJECTION_PROFILING_DISABLED, K8S_LIB_INJECTION_PROFILING_ENABLED, K8S_LIB_INJECTION_PROFILING_OVERRIDE]
      K8S_CLUSTER_VERSION: ['7.56.2','7.59.0']

save_versions:
  image: $DOCKER_REGISTRY/images/mirror/ruby:3.2.2
  stage: package
  needs: []
  script:
    - git fetch --all
    - echo COMMIT_SHA_1X=$(git rev-parse origin/1.x-stable) >> upstream.env
    - echo COMMIT_SHA_2X=$(git rev-parse origin/master) >> upstream.env
  artifacts:
    paths:
      - upstream.env

deploy_to_reliability_env:
  needs:
    - save_versions

vaccine:
  image: $DOCKER_REGISTRY/docker:20.10.13
  tags: [ "arch:amd64" ]
  stage: vaccine
  needs: [create-multiarch-lib-injection-image]
  script: |
    GH_VACCINE_PAT=$(vault kv get -field=vaccine-token kv/k8s/gitlab-runner/dd-trace-rb/github-token)
    REPO="TonyCTHsu/vaccine"
    POLL_INTERVAL=30  # seconds

    # Trigger workflow
    echo "Triggering workflow..."
    TRIGGER_RESPONSE=$(curl -X POST \
      -H "Accept: application/vnd.github.v3+json" \
      -H "Authorization: token $GH_VACCINE_PAT" \
      -w "\n%{http_code}" \
      "https://api.github.com/repos/$REPO/actions/workflows/vaccine.yml/dispatches" \
      -d '{"ref":"master", "inputs": {"commit_sha": "'$CI_COMMIT_SHA'"}}' 2>&1)

    HTTP_STATUS=$(echo "$TRIGGER_RESPONSE" | tail -n1)
    RESPONSE_BODY=$(echo "$TRIGGER_RESPONSE" | sed '$ d')

    if [ "$HTTP_STATUS" -eq 403 ]; then
      echo "Error: Workflow trigger failed - Authentication failed"
      echo "Response: $RESPONSE_BODY"
      exit 1
    elif [ "$HTTP_STATUS" -ne 204 ]; then
      echo "Error: Workflow trigger failed with status $HTTP_STATUS"
      echo "Response: $RESPONSE_BODY"
      exit 1
    fi

    echo "Successfully triggered workflow. Waiting for workflow to start..."
    sleep 10  # Give GitHub a moment to create the workflow run

    # Get the most recent workflow run
    echo "Fetching most recent workflow run..."
    RUNS_RESPONSE=$(curl -s \
      -H "Accept: application/vnd.github.v3+json" \
      -H "Authorization: token $GH_VACCINE_PAT" \
      -w "\n%{http_code}" \
      "https://api.github.com/repos/$REPO/actions/runs?event=workflow_dispatch&per_page=1" 2>&1)

    HTTP_STATUS=$(echo "$RUNS_RESPONSE" | tail -n1)
    RESPONSE_BODY=$(echo "$RUNS_RESPONSE" | sed '$ d')

    if [ "$HTTP_STATUS" -eq 403 ]; then
      echo "Error: Fetching runs failed - Authentication failed"
      echo "Response: $RESPONSE_BODY"
      exit 1
    elif [ "$HTTP_STATUS" -ne 200 ]; then
      echo "Error: Fetching runs failed with status $HTTP_STATUS"
      echo "Response: $RESPONSE_BODY"
      exit 1
    fi

    echo "Response body: $RESPONSE_BODY"

    # Get the most recent run ID
    WORKFLOW_ID=$(echo "$RESPONSE_BODY" | jq -r '.workflow_runs[0].id')

    if [ -z "$WORKFLOW_ID" ] || [ "$WORKFLOW_ID" = "null" ]; then
      echo "Error: Could not find recent workflow run"
      exit 1
    fi

    echo "Found workflow run ID: $WORKFLOW_ID"

    # Poll workflow status
    while true; do
      RUN_RESPONSE=$(curl -s \
        -H "Accept: application/vnd.github.v3+json" \
        -H "Authorization: token $GH_VACCINE_PAT" \
        -w "\n%{http_code}" \
        "https://api.github.com/repos/$REPO/actions/runs/$WORKFLOW_ID" 2>&1)

      HTTP_STATUS=$(echo "$RUN_RESPONSE" | tail -n1)
      RESPONSE_BODY=$(echo "$RUN_RESPONSE" | sed '$ d')

      if [ "$HTTP_STATUS" -eq 403 ]; then
        echo "Error: Fetching run status failed - Authentication failed"
        echo "Response: $RESPONSE_BODY"
        exit 1
      elif [ "$HTTP_STATUS" -ne 200 ]; then
        echo "Error: Fetching run status failed with status $HTTP_STATUS"
        echo "Response: $RESPONSE_BODY"
        exit 1
      fi

      STATUS=$(echo "$RESPONSE_BODY" | jq -r .status)
      CONCLUSION=$(echo "$RESPONSE_BODY" | jq -r .conclusion)

      if [ "$STATUS" = "completed" ]; then
        if [ "$CONCLUSION" = "success" ]; then
          echo "✅ Workflow completed successfully!"
          exit 0
        else
          echo "❌ Workflow failed with conclusion: $CONCLUSION"
          echo "See details: https://github.com/$REPO/actions/runs/$WORKFLOW_ID"
          exit 1
        fi
      fi

      echo "Current status: $STATUS (Checking again in ${POLL_INTERVAL}s)"
      sleep $POLL_INTERVAL
    done
