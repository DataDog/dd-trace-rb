module Datadog
  module OpenFeature
    module Binding
      class EvaluationError < ::StandardError
        attr_reader code: ::String
        attr_reader message: ::String

        def initialize: (::String code, ::String message) -> void
      end

      class InternalEvaluator

        def initialize: (::String ufc_json) -> void

        def get_assignment: (
          ::String flag_key,
          untyped _evaluation_context,
          ::Symbol? expected_type
        ) -> ResolutionDetails

        private

        def parse_and_validate_json: (::String ufc_json) -> (Configuration | ResolutionDetails)

        def create_parse_error: (::String error_code, ::String error_message) -> ResolutionDetails

        def create_evaluation_success: (
          untyped value,
          ::String variant,
          ::String allocation_key,
          bool do_log,
          ::String reason
        ) -> ResolutionDetails

        def create_evaluation_no_result: (::String reason) -> ResolutionDetails

        def create_evaluation_error: (::String error_code, ::String error_message) -> ResolutionDetails

        def type_matches?: (::String flag_variation_type, ::Symbol expected_type) -> bool

        def evaluate_flag_allocations: (
          Flag flag,
          untyped evaluation_context,
          ::Time time
        ) -> [Allocation?, Variation?, ::String]

        def find_matching_split_for_allocation: (
          Allocation allocation,
          untyped evaluation_context,
          ::Time evaluation_time
        ) -> [Split?, ::String?]

        def evaluate_rule: (Rule rule, untyped evaluation_context) -> bool

        def evaluate_condition: (Condition condition, untyped evaluation_context) -> bool

        def get_attribute_from_context: (::String attribute_name, untyped evaluation_context) -> untyped

        def evaluate_comparison: (untyped attribute_value, untyped condition_value, ::Symbol operator) -> bool

        def evaluate_membership: (untyped attribute_value, untyped condition_values, bool expected_membership) -> bool

        def evaluate_regex: (untyped attribute_value, untyped pattern, bool expected_match) -> bool

        def evaluate_null_check: (untyped attribute_value, untyped expected_null) -> bool

        def coerce_to_number: (untyped value) -> ::Float?

        def coerce_to_string: (untyped value) -> ::String?

        def coerce_to_boolean: (untyped value) -> bool?

        def get_targeting_key: (untyped evaluation_context) -> ::String?

        def split_matches?: (Split split, ::String? targeting_key) -> bool

        def shard_matches?: (Shard shard, ::String targeting_key) -> bool

        def compute_shard_hash: (::String? salt, ::String targeting_key, ::Integer total_shards) -> ::Integer

        def determine_assignment_reason: (Allocation allocation) -> ::String

      end
    end
  end
end
